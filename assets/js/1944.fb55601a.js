"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[1944],{71944:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>p,toc:()=>s});var o=t(58168),r=(t(96540),t(15680));t(60681);const a={title:"Higher-order Components",slug:"/react/hoc"},i=void 0,p={unversionedId:"react/hoc",id:"react/hoc",title:"Higher-order Components",description:"Higher-order components are discouraged in modern React code and will not be updated for Component Syntax.",source:"@site/docs/react/hoc.md",sourceDirName:"react",slug:"/react/hoc",permalink:"/en/docs/react/hoc",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/react/hoc.md",tags:[],version:"current",frontMatter:{title:"Higher-order Components",slug:"/react/hoc"},sidebar:"docsSidebar",previous:{title:"Ref Functions",permalink:"/en/docs/react/refs"},next:{title:"Render Types",permalink:"/en/docs/react/render-types"}},c={},s=[{value:"The Trivial HOC",id:"toc-the-trivial-hoc",level:3},{value:"Injecting Props",id:"toc-injecting-props",level:3},{value:"Preserving the Instance Type of a Component",id:"toc-preserving-the-instance-type-of-a-component",level:3},{value:"Exporting Wrapped Components",id:"toc-exporting-wrapped-components",level:3}],m={toc:s};function d(n){let{components:e,...t}=n;return(0,r.mdx)("wrapper",(0,o.A)({},m,t,{components:e,mdxType:"MDXLayout"}),(0,r.mdx)("admonition",{type:"danger"},(0,r.mdx)("p",{parentName:"admonition"},"Higher-order components are discouraged in modern React code and will not be updated for ",(0,r.mdx)("a",{parentName:"p",href:"../component-syntax"},"Component Syntax"),".\nConsider using a hook to accomplish your task instead.")),(0,r.mdx)("p",null,"A popular pattern in React is the ",(0,r.mdx)("a",{parentName:"p",href:"https://facebook.github.io/react/docs/higher-order-components.html"},"higher-order component pattern"),", so it's\nimportant that we can provide effective types for higher-order components in\nFlow. If you don't already know what a higher-order component is then make sure\nto read the ",(0,r.mdx)("a",{parentName:"p",href:"https://facebook.github.io/react/docs/higher-order-components.html"},"React documentation on higher-order components")," before\ncontinuing."),(0,r.mdx)("p",null,"You can make use of the ",(0,r.mdx)("a",{parentName:"p",href:"../component-types/"},"Component Types")," to annotate your higher order components."),(0,r.mdx)("h3",{id:"toc-the-trivial-hoc"},"The Trivial HOC"),(0,r.mdx)("p",null,"Let's start with the simplest HOC:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"import * as React from 'react';\n\nfunction trivialHOC<Config: {...}>(\n  Component: component(...Config),\n): component(...Config) {\n  return Component;\n}\n")),(0,r.mdx)("p",null,"This is a basic template for what your HOCs might look like. At runtime, this HOC doesn't\ndo anything at all. Let's take a look at some more complex examples."),(0,r.mdx)("h3",{id:"toc-injecting-props"},"Injecting Props"),(0,r.mdx)("p",null,"A common use case for higher-order components is to inject a prop.\nThe HOC automatically sets a prop and returns a component which no longer requires\nthat prop. For example, consider a navigation prop. How would one type this?"),(0,r.mdx)("p",null,"To remove a prop from the config, we can take a component that includes the\nprop and return a component that does not. It's best to construct these\ntypes using object type spread."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":27,"startColumn":2,"endLine":27,"endColumn":20,"description":"Cannot create `MyEnhancedComponent` element because property `b` is missing in props [1] but exists in object type [2]. [prop-missing]"}]','[{"startLine":27,"startColumn":2,"endLine":27,"endColumn":20,"description":"Cannot':!0,create:!0,"`MyEnhancedComponent`":!0,element:!0,because:!0,property:!0,"`b`":!0,is:!0,missing:!0,in:!0,props:!0,"[1]":!0,but:!0,exists:!0,object:!0,type:!0,"[2].":!0,'[prop-missing]"}]':!0},"import * as React from 'react';\n\ntype InjectedProps = {foo: number}\n\nfunction injectProp<Config>(\n  Component: component(...{...$Exact<Config>, ...InjectedProps})\n): component(...$Exact<Config>) {\n  return function WrapperComponent(\n    props: Config,\n  ) {\n    return <Component {...props} foo={42} />;\n  };\n}\n\nfunction MyComponent(props: {\n  a: number,\n  b: number,\n  ...InjectedProps,\n}): React.Node {}\n\nconst MyEnhancedComponent = injectProp(MyComponent);\n\n// We don't need to pass in `foo` even though `MyComponent` requires it:\n<MyEnhancedComponent a={1} b={2} />; // OK\n\n// We still require `a` and `b`:\n<MyEnhancedComponent a={1} />; // ERROR\n")),(0,r.mdx)("h3",{id:"toc-preserving-the-instance-type-of-a-component"},"Preserving the Instance Type of a Component"),(0,r.mdx)("p",null,"Recall that the instance type of a function component is ",(0,r.mdx)("inlineCode",{parentName:"p"},"void"),". Our example\nabove wraps a component in a function, so the returned component has the instance\ntype ",(0,r.mdx)("inlineCode",{parentName:"p"},"void"),"."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":22,"startColumn":40,"endLine":22,"endColumn":50,"description":"Cannot call `injectProp` with `MyComponent` bound to `Component` because `MyComponent` [1] is incompatible with instance of component [2]. [incompatible-call]"},{"startLine":29,"startColumn":27,"endLine":29,"endColumn":29,"description":"Cannot create `MyEnhancedComponent` element because in property `ref`: [incompatible-type] Either a call signature declaring the expected parameter / return type is missing in `React.RefObject` [1] but exists in function type [2]. Or `React.RefObject` [1] is incompatible with null [3]."}]','[{"startLine":22,"startColumn":40,"endLine":22,"endColumn":50,"description":"Cannot':!0,call:!0,"`injectProp`":!0,with:!0,"`MyComponent`":!0,bound:!0,to:!0,"`Component`":!0,because:!0,"[1]":!0,is:!0,incompatible:!0,instance:!0,of:!0,component:!0,"[2].":!0,'[incompatible-call]"},{"startLine":29,"startColumn":27,"endLine":29,"endColumn":29,"description":"Cannot':!0,create:!0,"`MyEnhancedComponent`":!0,element:!0,in:!0,property:!0,"`ref`:":!0,"[incompatible-type]":!0,Either:!0,a:!0,signature:!0,declaring:!0,the:!0,expected:!0,parameter:!0,"/":!0,return:!0,type:!0,missing:!0,"`React.RefObject`":!0,but:!0,exists:!0,function:!0,Or:!0,null:!0,'[3]."}]':!0},"import * as React from 'react';\n\ntype InjectedProps = {foo: number}\n\nfunction injectProp<Config>(\n  Component: component(...{...$Exact<Config>, ...InjectedProps})\n): component(...$Exact<Config>) {\n  return function WrapperComponent(\n    props: Config,\n  ) {\n    return <Component {...props} foo={42} />;\n  };\n}\n\n// A class component in this example\nclass MyComponent extends React.Component<{\n  a: number,\n  b: number,\n  ...InjectedProps,\n}> {}\n\nconst MyEnhancedComponent = injectProp(MyComponent);\n\n// If we create a ref object for the component, it will never be assigned\n// an instance of MyComponent!\nconst ref = React.createRef<MyComponent>();\n\n// Error, mixed is incompatible with MyComponent.\n<MyEnhancedComponent ref={ref} a={1} b={2} />;\n")),(0,r.mdx)("p",null,"We get this error message because component type doesn't declare the ",(0,r.mdx)("inlineCode",{parentName:"p"},"ref")," prop,\nso it is treated as ",(0,r.mdx)("inlineCode",{parentName:"p"},"React.RefSetter<void>"),". If we wanted to preserve the instance type\nof the component, we can use ",(0,r.mdx)("a",{parentName:"p",href:"https://reactjs.org/docs/forwarding-refs.html"},(0,r.mdx)("inlineCode",{parentName:"a"},"React.forwardRef")),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"import * as React from 'react';\n\ntype InjectedProps = {foo: number}\n\nfunction injectAndPreserveInstance<Config: {...}, Instance>(\n  Component: component(ref?: React.RefSetter<Instance>, ...{...$Exact<Config>, ...InjectedProps})\n): component(ref?: React.RefSetter<Instance>, ...$Exact<Config>) {\n  return React.forwardRef<$Exact<Config>, Instance>((props, ref) =>\n      <Component ref={ref} foo={3} {...props} />\n  );\n}\n\nclass MyComponent extends React.Component<{\n  a: number,\n  b: number,\n  ...InjectedProps,\n}> {}\n\nconst MyEnhancedComponent = injectAndPreserveInstance(MyComponent);\n\nconst ref = React.createRef<MyComponent>();\n\n// All good! The ref is forwarded.\n<MyEnhancedComponent ref={ref} a={1} b={2} />;\n")),(0,r.mdx)("h3",{id:"toc-exporting-wrapped-components"},"Exporting Wrapped Components"),(0,r.mdx)("p",null,"If you try to export a wrapped component, chances are that you'll run into a missing annotation error:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":13,"startColumn":36,"endLine":13,"endColumn":58,"description":"Cannot build a typed interface for this module. You should annotate the exports of this module with types. Cannot determine the type of this call expression. Please provide an annotation, e.g., by adding a type cast around this expression. [signature-verification-failure]"}]','[{"startLine":13,"startColumn":36,"endLine":13,"endColumn":58,"description":"Cannot':!0,build:!0,a:!0,typed:!0,interface:!0,for:!0,this:!0,"module.":!0,You:!0,should:!0,annotate:!0,the:!0,exports:!0,of:!0,module:!0,with:!0,"types.":!0,Cannot:!0,determine:!0,type:!0,call:!0,"expression.":!0,Please:!0,provide:!0,an:!0,"annotation,":!0,"e.g.,":!0,by:!0,adding:!0,cast:!0,around:!0,'[signature-verification-failure]"}]':!0},"import * as React from 'react';\n\nfunction trivialHOC<Config: {...}>(\n  Component: component(...Config),\n): component(...Config) {\n  return Component;\n}\n\ntype Props = $ReadOnly<{bar: number, foo?: number}>;\n\nfunction MyComponent({bar, foo = 3}: Props): React.Node {}\n\nexport const MyEnhancedComponent = trivialHOC(MyComponent); // ERROR\n")),(0,r.mdx)("p",null,"You can add an annotation to your exported component using component types:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"import * as React from 'react';\n\nfunction trivialHOC<Config: {...}>(\n  Component: component(...Config),\n): component(...Config) {\n  return Component;\n}\n\ntype Props = $ReadOnly<{bar: number, foo?: number}>;\n\nfunction MyComponent({bar, foo = 3}: Props): React.Node {}\n\nexport const MyEnhancedComponent: component(...Props) = trivialHOC(MyComponent); // OK\n")))}d.isMDXComponent=!0}}]);